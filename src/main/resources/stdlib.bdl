(defconst defmacro (macro (Name Args . Body)
    (list 'defconst Name (append (list 'macro Args) Body)))
    "Define a macro.")

(defmacro defun (Name Args . Body)
    "Define a function."
    (list 'defconst Name (append (list 'lambda Args) Body)))


;; car, cdr utility functions
(defun caar (X)
    (car (car X)))

(defun cadr (X)
    (car (cdr X)))

(defun cdar (X)
    (cdr (car X)))

(defun cddr (X)
    (cdr (cdr X)))

;; Aliases for builtin functions.
(defconst first car)
(defconst rest cdr)
(defconst = eq)

;; List utility functions.

(defun nth (Index List)
    "Return the nth element of the list."
    (cond
        ((null List) nil)
        ((eq Index 0) (first List))
        (t (nth (-1 Index) (rest List)))))

(defun size (List)
    "Return the size of the list."
    (defun size-iter (List Size)
        (cond
            ((null List) Size)
            (t (size-iter (rest List) (+1 Size)))))

    (size-iter List 0))

(defun member (Elem List)
    "Return true if the element is a member of the list."
    (cond
        ((null List) nil)
        ((eq Elem (first List)) t)
        (t (member (Elem (rest List))))))

(defun fold (Func Result List)
    "Take a two-argument function Func and fold down List to Result"
    (if (null List)
        Result
        (fold Func (Func Result (first List)) (rest List))))

(defun mapcar (Func List)
    "Process each element in List with Func."
    (if (null List)
        nil
        (cons (Func (first List)) (mapcar Func (rest List)))))

(defmacro push (Elem List)
    (list 'setq List (list 'cons Elem List)))

(defun range (Size)
    "Return a list of range Size from 0."
    (defun range-iter (Num Result)
        (if (<= Num 0)
            Result
            (range-iter (-1 Num) (cons Num Result))))

    (range-iter Size ()))

(defun reverse (List)
    "Returns a list with the same items, reversed."
    (defun reverse-iter (List Result)
        (cond
            ((null List) Result)
            (t (reverse-iter (cdr List) (cons (car List) Result)))))

    (reverse-iter List nil))

(defun assoc (Key Alist)
    "Search through an a-list and return a pair where its car matches the key."
    (cond
        ((null Alist) nil)
        ;; Return the first element if its car matches.
        ((eq Key (caar Alist)) (car Alist))
        ;; Go through assoc again, but cut off the first element from the list.
        (t (assoc Key (cdr Alist)))))

(defun assocr (Key Alist)
    "Search through an a-list and return a pair where its cdr matches the key."
    (cond
        ((null Alist) nil)
        ;; return the first element if its cdr matches.
        ((eq Key (cdar Alist)) (car Alist))
        ;; Go through assocr again, but without the a-list's first element.
        (t (assoc Key (cdr Alist)))))

;; Return whether the value is nil.
(defun null (X) (eq X nil))

;; Binary NOT
(defun not (Cond)
    "Return the logical inverse of Cond."
    (cond
        (Cond nil)
        (t t)))

(defmacro and (CondA CondB)
    "Return the second value if both values are truthy."
    (list 'cond (list CondA CondB)))

(defmacro or (CondA CondB)
    "Return t if either value is truthy."
    (list 'cond
        (list CondA t)
        (list CondB t)))

(defmacro if (Cond Truecase . Args)
    "Evaluate the Truecase if Cond is truthy; else, evaluate the second case if
    defined."
    ;; Should return nil if the third case doesn't exist.
    (defconst Falsecase (car Args))
    (list 'cond
        (list Cond Truecase)
        (list t Falsecase)))

(defmacro when (Cond . Body)
    "Evaluate the body if the condition is truthy."
    (list 'cond
        (list Cond (cons 'progn Body))))

(defmacro unless (Cond . Body)
    "Evaluate the body unless the condition is truthy."
    (list 'when (list 'not Cond) (cons 'progn Body)))

(defmacro until (Cond . Body)
    "Keep evaluating the body until the condition is truthy."
    (list 'while (list 'not Cond) (cons 'progn Body)))

;; Mathematical utilities.
(defun +1 (X)
    "Return the value plus 1."
    (+ X 1))

(defun -1 (X)
    "Return the value less 1."
    (- X 1))

(defun sum (List)
    (apply + List))

(defun avg (List)
    (/ (sum List) (size List)))

(defun min (List)
    "Return the smallest value from List."
    (defun min* (Current New)
        (cond
            ((null Current) New)
            ((> Current New) New)
            (t Current)))

    (fold min* nil List))

(defun max (List)
    "Return the largest value from List."
    (defun max* (Current New)
        (cond
            ((null Current) New)
            ((< Current New) New)
            (t Current)))

    (fold max* nil List))

(defmacro inc (X)
    "Increment the variable by 1 and return its result."
    (list 'progn
        (list 'setq X (list '+1 X))
        X))

(defmacro dec (X)
    "Decrement the variable by 1 and return its result."
    (list 'progn
        (list 'setq X (list '-1 X))
        X))