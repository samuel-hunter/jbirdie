;;; choose-your-bonus.bdl - example of HW1 in Birdie Lisp.

;; Constants
;; Workaround: there's as of yet no way to define constants (will be `defconst`
;; in the future), so use defvar for now.
(defvar *min-salary* 15080)
(defvar *max-salary* 470000)

;; An example of defining a list by using the quote shorthand.
(defvar *option-names*
    '("Option 1: $5,000 annual bonus (no pay increase)"
      "Option 2: 10% annual bonus based on salary (no pay increase)"
      "Option 3: 3% salary increase every year (no bonus)"))

;; An example of using lambdas to dynamically select a method.
(defvar *options*
        (list
         (lambda (Salary)
              ;; $5,000 annual bonus.
              (+ (* 3 Salary)
                 (* 2 5000)))
         (lambda (Salary)
              ;; 10% annual bonus.
              (* 3.2 Salary))
         (lambda (Salary)
              ;; 3% salary increase each year.
              (+ Salary
                 (* 1.03 Salary)
                 (* 1.03 1.03 Salary)))))

;; Prompt the user and use the given function. Example of using functions as a
;; first-class values by passing it in the function.
(defun prompt (Dialogue Promptfn)
    (print Dialogue)
    (Promptfn))

;; Return true when a value is between a minimum and maximum.
(defun within? (Min Value Max)
    (<= Min Value Max))

;; Prompt the user for a valid salary.
(defun prompt-salary ()
    ;; Example of a nested function, visible only to the outer function.
    (defun salary-valid? (Salary)
        ;; return true if the salary is between the max and min.
        (within? *min-salary* Salary *max-salary*))

    ;; Set the salary to a naturally invalid number.
    ;; Quirk: `-1` is a symbol, since it doesn't start with a number literal.
    ;; Use the function `-` instead to create a negative number.
    (defvar Salary (- 1))
    (while (not (salary-valid? Salary))
        (setq Salary (prompt "What's your current base salary? $" read-number))
        ;; Workaround: there is no `if` or `unless` defined yet, so use the
        ;;  low-level `cond` instead.
        (cond
            ((not (salary-valid? Salary))
             (println "The salary must be between $15,080 and $470,000!"))))

     ;; Return the salary.
     Salary)

;; Similar type of input validation. I /could/ generalize it to accept any
;; series of options, but I'm only using it for one set of options, so I won't
;; for this project.
(defun prompt-option ()
    (defvar OptionSize (size *option-names*))
    (defun option-valid? (Option)
        (within? 1 Option OptionSize))

    (println "How would you like to be rewarded for the next 3 years?")
    (foreach (Option *option-names*)
        (println Option))

    ;; Set the option to a naturally invalid number.
    (defvar UserOption (- 1))
    (while (not (option-valid? UserOption))
        (setq UserOption (prompt "> " read-number))
        (cond
            ((not (option-valid? UserOption))
             (println "Choose a valid option!"))))

    ;; Return the option converted from the user input.
    (nth (-1 UserOption) *options*)) ; decrement by 1.


(defun start ()
    (defvar Fname (prompt "What's your first name? " read-line))
    (defvar Lname (prompt "What's your last name? " read-line))
    (defvar Salary (prompt-salary))

    ;; Example of using a function as a value.
    (defvar Earnings ((prompt-option) Salary))

    ;; Print the result.
    (println (concat "Hello, " Fname " " Lname))
    (println (concat "Your salary is " (to-string Salary) "."))
    (println (concat
              "After 3 years, you would earn a total of $"
              (to-string Earnings)))
)

(start)